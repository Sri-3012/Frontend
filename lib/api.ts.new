const API_KEY = 'WTwIpag6HWAbz2L3VlWH';
const BASE_URL = 'https://marketdata.tradermade.com/api/v1';

interface ForexRate {
  price: number;
  bid: number;
  ask: number;
  change: number;
  percent_change: number;
  timestamp: number;
}

interface ForexData {
  [key: string]: ForexRate;
}

interface TraderMadeQuote {
  ask: number;
  bid: number;
  mid: number;
  base_currency: string;
  quote_currency: string;
  timestamp: number;
}

interface TraderMadeResponse {
  endpoint: string;
  quotes: TraderMadeQuote[];
}

function isValidNumber(value: any): boolean {
  return typeof value === 'number' && !isNaN(value) && isFinite(value);
}

function safeParseFloat(value: any, fallback: number = 0): number {
  if (value === null || value === undefined) return fallback;
  const parsed = parseFloat(value);
  return isValidNumber(parsed) ? parsed : fallback;
}

// Cache to store previous rates
let ratesCache: { [key: string]: { price: number; timestamp: number }[] } = {};
const MAX_CACHE_ENTRIES = 10;

function updateRatesCache(pair: string, price: number, timestamp: number) {
  if (!isValidNumber(price) || !isValidNumber(timestamp)) {
    console.warn(`Invalid cache update values for ${pair}:`, { price, timestamp });
    return;
  }

  if (!ratesCache[pair]) {
    ratesCache[pair] = [];
  }

  // Add new price to cache
  ratesCache[pair].push({ price, timestamp });

  // Keep only the last MAX_CACHE_ENTRIES entries
  if (ratesCache[pair].length > MAX_CACHE_ENTRIES) {
    ratesCache[pair].shift();
  }
}

function calculateChanges(pair: string, currentPrice: number): { change: number; percent_change: number } {
  if (!isValidNumber(currentPrice)) {
    console.warn(`Invalid current price for ${pair}:`, currentPrice);
    return { change: 0, percent_change: 0 };
  }

  const cache = ratesCache[pair];
  if (!cache || cache.length < 2) {
    return { change: 0, percent_change: 0 };
  }

  // Get the previous price
  const previousPrice = cache[cache.length - 2].price;
  if (!isValidNumber(previousPrice)) {
    console.warn(`Invalid previous price for ${pair}:`, previousPrice);
    return { change: 0, percent_change: 0 };
  }

  const change = currentPrice - previousPrice;
  const percent_change = (change / previousPrice) * 100;

  // Validate calculated values
  if (!isValidNumber(change) || !isValidNumber(percent_change)) {
    console.warn(`Invalid calculated changes for ${pair}:`, { change, percent_change });
    return { change: 0, percent_change: 0 };
  }

  return { change, percent_change };
}

export async function getForexPrices(pairs: string[]): Promise<ForexData | null> {
  try {
    if (!Array.isArray(pairs) || pairs.length === 0) {
      console.error('Invalid pairs array:', pairs);
      throw new Error('Invalid pairs array provided');
    }

    // Format pairs for TraderMade API (e.g., "EURUSD,GBPUSD")
    const formattedPairs = pairs.map(pair => pair.replace('/', '')).join(',');
    console.log('Fetching forex prices for:', formattedPairs);
    
    const url = `${BASE_URL}/live?currency=${formattedPairs}&api_key=${API_KEY}`;
    console.log('API URL:', url);
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    });

    const responseText = await response.text();
    console.log('Raw API Response:', responseText);

    if (!response.ok) {
      console.error('API Error Response:', {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries()),
        body: responseText
      });
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }
    
    let data: TraderMadeResponse;
    try {
      data = JSON.parse(responseText);
      console.log('Parsed API Response:', data);
    } catch (error) {
      console.error('Failed to parse API response:', error);
      throw new Error('Invalid JSON response from API');
    }

    if (!data || !data.quotes) {
      console.error('Invalid API response structure:', data);
      throw new Error('Invalid API response format: missing quotes');
    }

    if (!Array.isArray(data.quotes) || data.quotes.length === 0) {
      console.error('Empty or invalid quotes array in response:', data.quotes);
      throw new Error('Invalid API response format: invalid quotes structure');
    }

    // Transform the data to match our application's format
    const transformedData: ForexData = {};
    const timestamp = Date.now();

    // Process each currency pair
    data.quotes.forEach((quote) => {
      if (!quote || typeof quote !== 'object') {
        console.warn('Invalid quote data:', quote);
        return;
      }

      const symbol = `${quote.base_currency}/${quote.quote_currency}`;
      const price = safeParseFloat(quote.mid); // Use mid price as the main price
      const bid = safeParseFloat(quote.bid);
      const ask = safeParseFloat(quote.ask);
      
      // Only process if we have valid price data
      if (isValidNumber(price)) {
        // Store in cache for change calculation
        updateRatesCache(symbol, price, timestamp);
        const { change, percent_change } = calculateChanges(symbol, price);

        transformedData[symbol] = {
          price,
          bid,
          ask,
          change,
          percent_change,
          timestamp: safeParseFloat(quote.timestamp, timestamp)
        };
      } else {
        console.warn(`Skipping invalid price data for ${symbol}:`, quote);
      }
    });

    // Only return data if we have at least one valid entry
    return Object.keys(transformedData).length > 0 ? transformedData : null;
  } catch (error) {
    console.error('Error fetching forex prices:', error);
    return null;
  }
}

export async function getHistoricalData(symbol: string, interval: string = 'daily') {
  try {
    if (!symbol) {
      throw new Error('Invalid symbol provided');
    }

    // For historical data
    const date = new Date();
    date.setDate(date.getDate() - 7); // Get data for last 7 days
    const startDate = date.toISOString().split('T')[0];
    const endDate = new Date().toISOString().split('T')[0];
    
    const response = await fetch(
      `${BASE_URL}/timeseries?api_key=${API_KEY}&currency=${symbol.replace('/', '')}&start_date=${startDate}&end_date=${endDate}&interval=${interval}&format=json`
    );

    if (!response.ok) {
      throw new Error(`Historical data request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    if (!data.quotes || !Array.isArray(data.quotes)) {
      throw new Error('Invalid historical data format');
    }

    return {
      symbol,
      data: data.quotes.map((quote: any) => ({
        timestamp: new Date(quote.date).getTime(),
        open: safeParseFloat(quote.open),
        high: safeParseFloat(quote.high),
        low: safeParseFloat(quote.low),
        close: safeParseFloat(quote.close)
      })).filter(item => 
        isValidNumber(item.timestamp) && 
        isValidNumber(item.open) && 
        isValidNumber(item.high) && 
        isValidNumber(item.low) && 
        isValidNumber(item.close)
      )
    };
  } catch (error) {
    console.error('Error fetching historical data:', error);
    return null;
  }
}